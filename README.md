# КДЗ#1 по курсу ПиАА
## Выполнил Горковец Роман Романович, БПИ204
Среда разработки: CLion 2021.2.3

Дата выполнения: 22.02.2022

Результаты работы программы: ./results_nanos

***
### Чек-лист

Наименование | Статус
----- | -----
Все труебуемые виды сортировок | Done
Сохранение результатов расчетов в .csv формат | Done
Графики, их анализ | Done
Ассерт на условие отсортированности массива. В случае false - бросатеся исключение | Done
Программы были запущены несколько раз для чистоты эксперимента | Done
Значения итоговых файлов были усреднены для более точной картины происходящего | Done
Сохранение входных массивов в формате .csv | Done
Сохрвнение отсортированных входных массивов в формате .csv | Done
Подсчет времени сортировки в наносекундах | Done
Документация к коду | Done


***
### Запуск:
Запуск main.cpp

**СMakeLists уже создан**

***
### Вывод
Все необходимые(в рамках задания) графики расположены в таблице results_nanos/result_table.xlsx. В результате анализа, я смог прийти к нескольким выводам:
- Наилучший результат среди квадратичных сортировок без показывает сортировка бинарными вставками, но в то же время она достаточно чувствительна к виду входных данных - 
что смогла обойти сортировка выбором, которая к этому критерию оказалась "равнодушна". Однако, справедливо будет подметить, что сортировка вставками достаточно хорошо работает с почти отсортированными входными данными. Целесообразность использования таких сортировок определяется размером входных данных ( лучше - меньше) и временем, выделяемым на решение задачи. Пузырек, несмотря на свою ужасную производительность, очень прост для понимания и максимально хорошо подходит для обучающих целей.
- Самые лучшие результаты на приведенных наборах данных показывает Count Sort, но ввиду того, что его работа осуществляется за счет поиска минимума и максимума исходного массива
и выделением памяти в размере  sizeof(TypeName) * (max-min+1), то это решение иногда может "кушать" слишком ного памяти. Что, безусловно, является минусом данного алгоритма. Еще один линейный алгоритм - Radix Sort крайне слабочувствителен к входным данным. Случайные ли это числа или почти отсортированные - алгоритм работает примерно за то же время.
- Из сортировок имеющих сложность O(nlogn) однозначно побеждает быстрая сортировка с разбиением Хоара. Если сравнить показатели этого разбиения с вариантом Ломуто, то можно заметить, что второй крайне неэффективен при обработке обратно отсортированного массива. Недостаток заключается в выборе pivot'а. В разбиении Ломуто он выбирается как последний элемент диапазона, что, в данном случае, приводит к большому количеству swap'ов. Можно выделить и сортировку слиянием и пирамидоидальную, которые практически не чувствительны к входным данным. Это также является и минусом сортировок, т.к. почти отсортированный массив сортируется так же долго, как совершенно рандомный.
- Условия Айверсона в пузырьковой сортировки не дают значительных преимуществ во времени исполнении алгоритма. А в случае массива, сгенерированного из случайных целых чисел в диапазоне от 0 до 5, так и вовсе замедляют работу алгоритма.

Таким образом, у каждой из предложенных сортировок есть "право на жизнь". В то время, как одни сортировки работают одинаково средне на разных видах данных, другие хорошо справляются с задачей сортировки массива конкретного паттерна. Это может быть и недостататком, и преимуществом алгоритма одновременно - многое зависит от поставленной задачи. Поэтому одной из лучших практик в наше время является комбинирование сортировок. Так, например, работают встроенный "питоновский" TimSort и "плюсовый" IntroSort. Однако, если попыться объединить ключевые факторы при выборе сортировки из алгоритмов, рассмотренных в рамках данной работы, одним из лучших алгоритмов, сочетающим в себе скорость исполнения и малые затраты по памяти, станет быстрая сортировка, несмотря на ее неустойчивость и рекурсивную реализацию.
